# 7장 타입, 메서드, 인터페이스

Go 는 계층구조가 없는 유연한 타입 시스템을 제공한다. Go 개발자들은 합성(composition) 과 마찬가지 방법으로, 기능을 재사용하기 위해 타입을 임베드(embed) 한다.
Go 는 전통적인 상속 기반의 모델에 비해 훨씬 작은 타입을 합성하여 타입을 정의한다.

Go 는 모델의 타입을 모델링하는 것이 아니라 동작을 모델링할 수 있는 독특한 인터페이스를 구현한다. Go 에서는 어떤 타입이 인터페이스를 구현하고 있다는 것을 선언할 필요가 없다.
컴파일러는 현재 사용하고 있는 타입의 값이 사용하고자 하는 인터페이스를 만족하는지 검사할 뿐이다. Go 표준 라이브러리의 인터페이스 대부분은 겨우 몇 가지 기능만을 노출하는 간단한 것들이다.
Java 같은 객체지향 언어에 익숙한 독자(it's me...) 라면 읻굿해지는 데 시간이 좀 걸릴 것이다.

---

Go 는 정적 타입 프로그래밍 언어다. 즉, 컴파일러가 프로그램 내의 모든 값의 타입을 정확히 알고 있다. 
이를 통해 프로그램은 더 안전하게 값을 활용할 수 있다. 컴파일러는 값의 타입을 이용해 두 가지 정보를 얻을 수 있다.

1. 값에 할당해야 하는 메모리의 크기
2. 할당된 메모리를 통해 표현할 수 있는 값의 종류

e.g.) int64 타입은 - 8바이트 공간 차지/ 정수 값 표현

---

1. [Go의 타입](7.1.md)
2. [메서드](section02/README.md)
3. [구성을 위한 임베딩 사용](7.3.md)
4. 임베딩은 상속이 아니다
5. [인터페이스에 대한 간단한 지도](7.5.md)
6. [인터페이스는 타입에 안정적인 덕 타이핑이다](7.6.md)
7. [임베딩과 인터페이스](7.7.md)
8. [인터페이스를 받고 구조체 반환하기](7.8.md)
9. 인터페이스와 nil
10. 빈 인터페이스는 어떤 것도 표현하지 않는다
11. 타입 단언 및 타입 스위치
12. 타입 단원과 타입 스위치를 아껴 사용하기
13. 함수 타입은 인터페이스로의 연결
14. 의존성 주입을 쉽게 만든느 암묵적 인터페이스
15. Wire
16. Go는 특히 객체지향이 아니다
17. 마무리